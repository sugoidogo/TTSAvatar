<!DOCTYPE html>

<body>
    <img id="img" src="/loader.gif">
    <audio autoplay="true" id="audio"></audio>
    <div id="controls">
        <label for="mode">Voice Mode</label>
        <select id="mode" oninput="setMode(this.value)">
            <option value="local">Local</option>
            <option value="streamelements">StreamElements</option>
        </select>
        <div id="local">
            <label for="voice">Voice</label>
            <select id="voice" oninput="update('voice',this.value)"></select>
            <br>
            <label for="volumeRange">Volume</label>
            <input id="volumeRange" type="range" min="0" max="1" step="0.01" oninput="update('volumeNumber',this.value)">
            <input id="volumeNumber" type="number" min="0" max="1" step="0.01" oninput="update('volumeRange',this.value)">
            <br>
            <label for="rateRange">Rate</label>
            <input id="rateRange" type="range" min="0.1" max="10" step="0.1" oninput="update('rateNumber',this.value)">
            <input id="rateNumber" type="number" min="0.1" max="10" step="0.1" oninput="update('rateRange',this.value)">
            <br>
            <label for="pitchRange">Pitch</label>
            <input id="pitchRange" type="range" min="0" max="2" step="0.1" oninput="update('pitchNumber',this.value)">
            <input id="pitchNumber" type="number" min="0" max="2" step="0.1" oninput="update('pitchRange',this.value)">
        </div>
        <div id="streamelements">
            <label for="pollyvoice">Polly Voice</label>
            <input id="pollyvoice" type="text" oninput="storage.setItem('pollyvoice',this.value)">
        </div>
        <br>
        <label for="silent">Silent Image or GIF</label>
        <input type="file" accept="image/*" oninput="setImg(this.files[0],'silent')">
        <img id="silent">
        <br>
        <label for="talking">Talking Image or GIF</label>
        <input type="file" accept="image/*" oninput="setImg(this.files[0],'talking')">
        <img id="talking">
    </div>
</body>
<style>
    #img {
        width: 100vw;
        height: 100vh;
        object-fit: contain;
        position: fixed;
        top: 0;
        left: 0;
    }

    img {
        height: 33vh;
    }

    label {
        display: inline-block;
        width: 30vh;
    }

    select,
    input[type=text] {
        display: inline-block;
        width:60vh;
    }

    input[type=range],
    input[type=file] {
        display: inline-block;
        width: 40vh;
    }

    input[type=number] {
        display: inline-block;
        width: 10vh;
    }

    #controls {
        position: fixed;
        top: 0;
        left: 0;
        height: 100vh;
        width: 100vw;
        opacity: 0;
    }

    #controls:hover {
        opacity: 100;
        background-color: white;
    }

    audio {
        opacity: 0;
    }

    * {
        font-size: 3vh;
    }
</style>
<script src="https://cdn.rawgit.com/mozilla/localForage/master/dist/localforage.js"></script>
<script>
    const params = new Proxy(new URLSearchParams(document.location.search), {
        get: (searchParams, prop) => searchParams.get(prop),
    });
    const client_id = params.client_id;
    const access_token = params.access_token;
    const storage = localforage;
    const error = '/error.png';
    const img = document.getElementById('img');
    const silent = document.getElementById('silent');
    const talking = document.getElementById('talking');
    const audio = document.getElementById('audio');
    const localdiv=document.getElementById('local');
    const streamelementsdiv=document.getElementById('streamelements');
    const pollyvoice=document.getElementById('pollyvoice');
    const tts = new SpeechSynthesisUtterance();
    const synth = window.speechSynthesis;
    const headers = {
        'Authorization': 'Bearer ' + access_token,
        'Client-Id': client_id,
        'Content-Type': 'application/json'
    }
    let bid, rid, tid, voices, local;

    function setMode(mode){
        switch (mode){
            case 'local':
                local=true;
                localdiv.hidden=false;
                streamelementsdiv.hidden=true;
                break;
            case 'streamelements':
                local=false;
                localdiv.hidden=true;
                streamelementsdiv.hidden=false;
                break;
        }
        storage.setItem('mode',mode);
    }

    audio.onplay=function(){
        img.src=talking.src;
        setPaused(true);
    }

    audio.onended=function(){
        img.src=silent.src;
        setPaused(false);
    }

    tts.onend = function () {
        img.src = silent.src;
    }

    function update(name, val) {
        const element = document.getElementById(name);
        name = name.replace('Range', '').replace('Number', '');
        storage.setItem(name, val);
        if (name != 'voice') {
            element.value=val;
            tts[name]= val;
            return;
        }
        tts.voice=voices[val]
    }

    function delay(time) {
        return new Promise(resolve => setTimeout(resolve, time));
    }

    tts.onboundary = async function () {
        img.src = silent.src;
        await delay(100);
        img.src = talking.src;
    }

    async function getBID() {
        const response = await fetch('https://api.twitch.tv/helix/users'
            , {
                headers: headers
            }
        )
        const json = await response.json()
        bid = json['data'][0]['id'];
    }

    async function getReward() {
        let url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards');
        url.search = new URLSearchParams({
            broadcaster_id: bid,
            only_manageable_rewards: true
        });
        let response = await fetch(url, {
            headers: headers
        });
        let json = await response.json();
        try {
            rid = json['data'][0]['id'];
        } catch (e) {
            url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards');
            url.search = new URLSearchParams({
                broadcaster_id: bid
            });
            response = await fetch(url, {
                headers: headers,
                method: 'POST',
                body: JSON.stringify({
                    title: 'TTS',
                    cost: 1,
                    is_enabled: false,
                    is_user_input_required: true,
                    is_global_cooldown_enabled: true,
                    global_cooldown_seconds: 60
                })
            });
            json = await response.json();
            try {
                rid = json['data'][0]['id'];
                window.alert('TTS Redeem has been added to your channel, please enable and edit it to your preferences');
            } catch (ee) {
                img.src = error;
                window.alert('TTSAvatar init failed. Most likely you need to delete an existing tts redeem from your channel.');
                throw ee;
            }
        }
        return rid;
    }

    async function setPaused(paused = true) {
        const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards');
        url.search = new URLSearchParams({
            broadcaster_id: bid,
            id: rid
        });
        fetch(url, {
            method: 'PATCH',
            headers: headers,
            body: JSON.stringify({
                is_paused: paused
            })
        })
    }

    async function main() {
        const url = new URL('https://api.twitch.tv/helix/channel_points/custom_rewards/redemptions');
        url.search = new URLSearchParams({
            broadcaster_id: bid,
            reward_id: rid,
            status: 'UNFULFILLED',
            after: await storage.getItem('cursor') || '',
            first: 1
        })
        const response = await fetch(url, {
            headers: headers
        });
        const json = await response.json();
        try {
            speak(json['data'][0]['user_input']);
            storage.setItem('cursor', json['pagination']['cursor'] || '')
        } catch (e) {}
    }

    function speak(message){
        if(local){
            tts.text = message;
            synth.speak(tts);
        }else{
            const url=new URL('https://api.streamelements.com/kappa/v2/speech');
            url.search=new URLSearchParams({
                voice:pollyvoice.value,
                text:message
            });
            audio.src=url;
        }
    }

    async function init() {
        try {
            await getBID();
            await getReward();
            tid = setInterval(main, 1000);
            voices=synth.getVoices();
            talking.src = await storage.getItem('talking') || '';
            silent.src = await storage.getItem('silent') || '';
            tts.onend();
            for(name of ['volume','rate','pitch']){
                let val=storage.getItem(name) || 1;
                if(!isFinite(val)){
                    val=1;
                }
                tts[name]=val;
                document.getElementById(name+'Range').value=val;
                document.getElementById(name+'Number').value=val;
            }
            pollyvoice.value=await storage.getItem('pollyvoice') || 'Brian';
            const vselect=document.getElementById('voice');
            for(index in voices){
                const option=document.createElement('option');
                option.value=index;
                option.text=voices[index].name;
                vselect.add(option);
            }
            setMode(await storage.getItem('mode') || 'local');
        } catch (e) {
            window.alert(e);
            img.src = error;
            throw e;
        }
    }

    function setImg(file, name) {
        let element = document.getElementById(name);
        reader = new FileReader();
        reader.onload = function (event) {
            element.src = event.target.result;
            storage.setItem(name, event.target.result);
            if (name == 'silent') {
                img.src = event.target.result;
            }
        }
        reader.onerror = function (event) {
            window.alert(event);
        }
        reader.readAsDataURL(file);
    }

    window.onload=init;
</script>